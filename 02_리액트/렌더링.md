## 추후 정리 예정

- 브라우저 렌더링
  - 리랜더링 과정
- real dom / virtual dom

<br/>

## 리액트 렌더링이 발생하는 경우

> **아래에 언급된 경우 외에는 리액트에서 렌더링이 발생하지 않음**

1. 최초 렌더링
2. 리렌더링

   ### 2-1. 클래스 컴포넌트에서 리렌더링이 발생하는 경우

   - **`setState()` 호출 시**
   - **`forceUpdate()` 호출 시**
     - 개발자가 **강제로 렌더링이 필요하다고 선언**한 것으로 간주
     - 이 경우 `shouldComponentUpdate()`는 **무시**되고 건너뜀

   ### 2-2. 함수 컴포넌트에서 리렌더링이 발생하는 경우

   - **`useState()`의 setter 함수 호출 시**  
     → 상태 변경이 발생하면 컴포넌트가 리렌더링됨
   - **`useReducer()`의 dispatch 함수 호출 시**  
     → 상태 업데이트 후 컴포넌트 리렌더링
   - **컴포넌트의 `key` prop이 변경될 경우**  
     → React는 해당 컴포넌트를 **완전히 다른 컴포넌트로 간주**  
     → 기존 컴포넌트를 언마운트하고 새로 마운트 → **렌더링 발생**
   - **props가 변경되는 경우**  
     → 부모로부터 전달받은 값이 달라지면 리렌더링
   - **부모 컴포넌트가 리렌더링될 경우**  
     → 자식 컴포넌트도 **함께 리렌더링**될 수 있음 (메모이제이션 없을 경우)

## 리액트 렌더링 프로세스

> 리액트는 내부적으로 렌더링을 두 단계로 나누어 처리하며, 기본적으로 **동기식으로 작동**함.  
> 리액트 18부터는 **비동기 렌더링(Concurrent Rendering)** 이 도입되어, 렌더링 우선순위 조정이 가능해짐.

### 1. 렌더링 프로세스

- 렌더링이 시작되면 리액트는 **루트 컴포넌트에서 시작해 하위 컴포넌트로 내려가며**,  
  **업데이트가 필요한 컴포넌트를 탐색**함
- 업데이트가 필요하다고 판단된 컴포넌트를 발견하면 다음 작업 수행:

  - **클래스 컴포넌트**: 내부의 `render()` 메서드를 호출
  - **함수 컴포넌트**: 함수 자체(FunctionComponent)를 실행하여 결과물(JSX)을 반환

- JSX 결과물은 **React.createElement()** 호출 구문으로 변환되어 가상 DOM을 구성함

### 2. 렌더 단계 vs 커밋 단계

#### 2-1. 렌더 단계 (Render Phase)

- 컴포넌트를 실행하여 (`render()` or `return`) 결과물을 생성함
- 이전 가상 DOM과 새로운 결과물을 비교(diffing)하여 **업데이트가 필요한 컴포넌트**를 체크
- 비교 기준:
  - `type`
  - `props`
  - `key`
- 변경된 것이 하나라도 있다면 → 해당 컴포넌트는 **업데이트 대상으로 마크됨**
- 이 과정에서 **새로운 가상 DOM(Virtual DOM)** 이 생성됨
- 이 단계에서는 실제 DOM은 변경되지 않음

#### 2-2. 커밋 단계 (Commit Phase)

- 렌더 단계에서 감지된 변경 사항을 **실제 DOM(리얼 DOM)** 에 적용
- 주요 작업:
  - **DOM 변경 적용**
  - **내부 참조 업데이트** (컴포넌트 인스턴스와 DOM 노드 간 연결 갱신)
  - 이후, 생명주기 및 훅 실행:
    - 클래스 컴포넌트: `componentDidMount`, `componentDidUpdate`
    - 함수 컴포넌트: `useLayoutEffect`

### 3. 렌더링 동기/비동기 방식

- **기본 동작**:  
  리액트는 기본적으로 렌더링을 **동기적으로 수행**함  
  → 렌더링 시간이 길어질수록 브라우저 응답성 및 성능 저하 발생

- **React 18+: 비동기 렌더링(Concurrent Rendering)**

  - 렌더 단계가 비동기로 작동

    → 특정 렌더링의 우선순위를 변경하거나 필요 시 중단, 재시작, 포기 가능
